**Portfolio Points:**

# 1a) Architecture of the entire system

Imagine you are a student with the stress of approaching exams. You want to head into university to study, but recently the libraries have been very busy, and you aren&#39;t sure you will be able to find a free chair. The last few times you have been in you have wasted half an hour going from library to library before giving up and heading home. Enter FindADesk! An application which allows students to see exactly where all the free seats are across campus, taking away the stress of finding free chairs in university study spaces. At the same time, this allows the university to better manage study spaces so they can be used more efficiently.

The system centers around &#39;chair&#39; objects, with 3 different sub-systems all interacting with the &#39;chair&#39; objects in different ways. These 3 sub-systems communicate with each other, sending information regarding the number and location of chairs, the state that any chairs are currently in and if there is a booking made for the chair. This allows students to see exactly where any chairs are and whether they are available. The communication is carried out by sending JSON objects through MQTT, a lightweight messaging protocol, with the messages automated by the programs in the applications.

![](RackMultipart20200503-4-w63zyv_html_9f7ca46d025e684c.png)

# 1c) Requirements of key sub-systems (in the form of selected user stories)

- **Students and administrators need a straightforward, easy to use UI for each of the subsystems which visually represent product&#39;s concept and functionality.**

One of the 3 subsystems of our product is the desktop application that administrators can use to design rooms, add tables and chairs, and view maintenance reports. Some examples of user stories for this are:

- An administrator wants to create new study spaces at their university and display this information to students, so they open the desktop application and add a new study space. This includes creating rooms, desks, chairs and buildings and being able to manage the IDs of these separate entities.

- An administrator wants to be able to find the locations of chairs that are faulty in order to schedule maintenance.

- An administrator wants to be able to monitor usage in each of the different study spaces.

The second subsystem of our product is the web application that students use to view the learning spaces, the available chairs in each and to make a booking for a chair. Some user stories are:

- A student who is new to a university wants to see a list of all the available buildings and rooms where they can study.

- A student who wants to go into university to study is not sure they will find a study space to work. They want to check if there are free seats available.

- A student is not sure whether seats will still be available by the time they get into the university. They want to be able to make a booking to guarantee a space for when they arrive.

- A student struggles to study when rooms are very busy and noisy. They want to be able to easily check which study spaces are the quietest at the university.

The final component of our product is the M5Stack which is attached to the back of every chair and displays the chairs current state. Some examples of user stories for this are:

- A student working at a desk wants to be able to leave the desk for breaks/lunch without the worry of having their desk taken by another student in their absence.

- A student looking around a library for a seat sees a desk with a bag near it, but nobody is sitting in the chair, so they aren&#39;t sure if the chair is still in use.

- An administrator has been tasked with installing the physical M5 stack devices on each chair. Rather than setting the chair, room and building IDs in the code and downloading to every device manually, a setup state was needed. The IDs could then be manually configured while installation took place.

- A librarian walking around the library notices that a chair is broken. They think it would be useful to have a system of reporting these broken chairs.

# 1b) Object-Oriented design of key sub-systems (e.g. Desktop Application, Web Application etc.)

![](RackMultipart20200503-4-w63zyv_html_9360beb4be1e1d6a.png)

The chair object is initially generated by the desktop application – this is the subsystem used by an institution administrator to implement the visual representation of their university&#39;s study spaces. This is achieved through the creation of building, room and desk objects which can be added or removed to reflect the volume and rough visual layout of desks on a room by room basis. Once a room and its desks have been added, the associated data of the room (its parent building id and name, its own name and id as well as the number of tables it contains) is published to the web application via a JSON string. The processing application also receives MQTT messages from the chair if it sets a status that requires action by the administrator (this is primarily if it is broken). This report is generated and is visible by the administrator so that they can take appropriate action.

The Processing application is built around a cascade of objects representing buildings, rooms, desks and chairs. These each contain an Array of objects such that buildings contain rooms which contain desks which have chairs.

The building and room classes have both name and ID attributes, while each subsequent sub-object also stores the ID of its parents such that a desk, for example, will also have attributes denoting the IDs of the room and building to which it belongs. The chair is somewhat different; its ID (instead of being an integer) is a string composed of the cumulative ids of its parents combined with its own ID. This ID is unique per room. This allows the processing app to easily send chair information to the web app and subsequently receive chair information from the stack. We did not see much value in using inheritance in the application, primarily because the objects function as data structures with little extra functionality gained from using it. In effect, the desktop application uses Object Oriented design to closely mirror the real world layout of a library / study space, and to also act as data storage containers for easy communication between applications (_see Figure_).

![](RackMultipart20200503-4-w63zyv_html_b471aa9e1d3028b7.png)

Our desktop application also contains classes representing the main dashboard and one which updates the view based on the user&#39;s interaction. The view class updates the dashboard and also handles the user interactions with the application, including adding rooms and desks. The main dashboard class sets up the dashboard, draws the tables and handles the parsing and publishing of MQTT messages (this will change).

The web application, built using HTML, CSS and node.js, is designed for students who wish to see the current states of the rooms. It shows an overview of all the different chair objects, showing which buildings and rooms they are contained in and its current state. It is run using an express server, so it can continuously be checking for messages from the other devices. It subscribes to the desktop application through MQTT so that the website can be updated with the correct number of rooms in each building and the correct number of tables within each room. It is assumed for this prototype that there are four chairs per table and this is calculated on the web application when displaying the number of chairs in each room. The information is saved in a NoSQL database (MongoDB) so that information can be reloaded (rather than the desktop application continuously sending messages regarding the current room states). The web application also subscribes to the M5Stack so that it can update the web page with the current state of the different chair objects (occupied, free, booked or at lunch). Using this information, students are able to see the current occupancy of each room and to make a choice about where they would like to study. Further to this, a student is able to select a chair and make a booking. This will subsequently publish a message to the M5Stack for that particular chair object, reserving it for that user. When the chair becomes free again the M5Stack will send a message back to the web application, informing it that it is now free.

![](RackMultipart20200503-4-w63zyv_html_833025e180783181.png)

_Figure 1 State diagram for the M5 stack_

The M5 Stack subsystem is responsible for detecting the current state of the chair and displaying it, which is determined by following the above state machine diagram. When the stack initialises for the first time, it enters the &#39;Setup state:

![](RackMultipart20200503-4-w63zyv_html_74fac94e95629cef.jpg)

_Figure 2 Setting the IDs within the &#39;Setup&#39; state_

Here the user can enter the relevant building, room and chair IDs on to the stack directly using the buttons.

Once setup is complete the stack enters the &#39;free&#39; state, then stays in free until one of the stated conditions is met:

![](RackMultipart20200503-4-w63zyv_html_5fe6b16d69c2499b.jpg)

It can only then move between the states which are connected by the arrows shown above (e.g. it cannot move from &#39;booked&#39; to &#39;at lunch&#39; directly). The stacks onboard accelerometer is used to measure vibration from the chair, and if it is above a certain threshold the state then moves to &#39;occupied&#39;:

![](RackMultipart20200503-4-w63zyv_html_1cc957835d0dd762.jpg)

While in use, the leftmost button can be used to start the chair user&#39;s lunch break, initialising a 45-minute timer in which the chair is reserved and cannot leave this state. To exit this state, either the user must scan their U-Card, returning the chair to the &#39;occupied&#39; state, or the timer can run out, returning to the &#39;free&#39; state (because evidently the user hasn&#39;t made it back in time from lunch, so their seat is now available).

From &#39;free&#39;, the chair can also change to the &#39;booked&#39; state, which means that a user has reserved that seat through the website application. This initialises a 10-minute timer, allowing the user to get to the seat and scan their U-Card, changing the state of the chair to &#39;occupied&#39;:

![](RackMultipart20200503-4-w63zyv_html_1825e9d1dc34af39.jpg)

If they fail to scan their U-Card within 10 minutes, the chair state reverts to &#39;free&#39;. A fifth administrator state was added to the state machine, allowing the chair to be declared &#39;broken&#39; if an administrator U-Card is scanned and the leftmost button is pressed.Changing to this state then notifies the processing application that a chair is broken so it can be repaired – the only way out of this state is for an admin to once again scan their U-Card and press a button, thereby preventing the chair from being used when it is broken.

![](RackMultipart20200503-4-w63zyv_html_ae2851e8dbb285e.png)

When the stack changes between two states, it publishes its new state to the MQTT WebSocket (which the web client receives and updates on the website and within the database). This can be seen in the diagram above; where a condition is met, the state is changed and published to MQTT, and then the stack loops through its new state until another condition is met and the state changes again.

The stack can also receive information from the website and send information to the processing application. Both of these are compartmentalised and it is only able to receive the &#39;booked&#39; command from the website when it is in &#39;free&#39; mode (as dictated by the state machine), and it will only send out information to the processing application when it enters the &#39;broken&#39; state (this is also achieved through the use of MQTT).

In terms of Object-Oriented design, the code for the stack itself is written in C++ in a functional way, but in terms of the entire system the stack in itself is very much a Stack object, which has an id and a state which can be passed around and stored by the processing and web applications.

# 1d) The evolution of UI wireframes for key sub-systems

Processing

In terms of UI, we first experimented with having a search bar to find buildings. This proved to be both difficult to implement and difficult to use for the user. Based on user feedback, we decided instead to use dropdown lists for users to navigate through buildings and rooms. We tried to do this by adapting the code from the processing code walkthrough, however quickly found out that it only partially fulfilled what we wanted to get done. By using controlP5 and by creating functions with the same names as the controlP5 controllers we were creating (similar to how you write code in CSS/javascript) we were able to extract which items were being clicked in the drop down lists and from that we could start to navigate between classrooms and display them individually (_image 2)_. The fundamental design of our UI revolves around showing the user a graphical representation of the desks and chairs on a room by room basis. Available chairs are shown in green while red chairs signal any other status. Clicking on a drop-down menu and selecting a building and room allows users to add a new desk to the room one at a time. The user can also choose to add a new room to the selected building. Users understood the UI intuitively and needed little help navigating it. One user however did comment that when creating a new room, the program should automatically navigate to the new room instead of it having to be selected post-creation. This happened after the user accidentally added more desks to the current room instead of the new one.

![](RackMultipart20200503-4-w63zyv_html_bb1a5d4bc7ea612b.jpg)

The initial user interface designs for the M5Stack were basic, simply indicating the current state with text and a unique colour so that the user could see the state of the chair from a distance. The &#39;lunch&#39; and &#39;booked&#39; states also had timers counting down to indicate the time left in that state – both reverted back to free if the timers expired without any user input. The lunch and booked states were originally designed for the user to be able to scan their U-Card to access that chair, but as an initial temporary measure the user simply had to press the left-most button to access the chair.

**Add real pictures of latest designs – with date/time, chair ID/ lunch prompt**

**(Also insert pictures from video demonstration?)**

_Later versions of the UI include a time/date in the corner, along with each chair id which allows administrators to know the chairs intended location within a room_ (by checking against the web/processing app). _A prompt on the &#39;in use&#39; screen also tells the user that they can start their lunch break by pressing the leftmost button._ Implementing an RFID scanner was attempted to add the ability to scan a U-Card so it could be accessed from the &#39;lunch&#39; and &#39;booked&#39; states, however this proved exceptionally difficult. _As a more suitable temporary measure, a unique combination of button presses, which is sent to their account on the web app, is now required by the user to disable these states._

**Add picture of &#39;broken&#39; state**

_As a later design change, we also added in the fifth state of &#39;broken&#39;, which allows an administrator to scan their U-Card, press a button and report the chair as broken to the processing application (so they can arrange for it to be repaired)._ **USER STORY**

**Add picture of &#39;setup&#39; state (if we decide to do it)**

_Finally, so that the stacks could be more &#39;plug and play&#39; and the id isn&#39;t hard-coded, we created a sixth &#39;setup&#39; mode which the stack initialises in to, allowing an administrator to set the 8 digit chair id. This screen will only show on first use, so every other time the stack starts it will go straight to the &#39;free&#39; state._ **USER STORY**

AND PICTURES OF THE OLD UI WIREFRAMES

For the web application UI wireframes we started with a basic paper prototype, we tested this on volunteers to try and get some early feedback.

Some of the key points included:

- What is the purpose of the application. What are users supposed to get out of it?
- Oftentimes users had to be guided towards the next page - the flow wasn&#39;t natural to them.
- Colour of chairs not explained (e.g. green = free, red = occupied). A colour key would be beneficial.

Based on this feedback, changes were made to the wireframes before beginning implementation of the website.

The UI layout was reassessed with each subsequent iteration/sprint and the design was changed based on the user feedback. Some of the comments recorded over subsequent sprints are:

- Wasn&#39;t clear how many free chairs in a room. Did the number on room overview page refer to total chairs or total free chairs?
- Not clear about booking time. For example, how long do I have to get there?
- How to identify what chair I have booked? Is there an ID/code?

Changes to the UI were continuously updated based on these feedback comments throughout the iterations.

![](RackMultipart20200503-4-w63zyv_html_4eebc738594c7f1e.png)

_Changes in the UI design of one of the web pages over time_

# 1e) Communication protocols in use

## MQTT **messaging protocol**

MQTT, a lightweight messaging protocol, was used for communication between the different applications. The MQTT transfers information as text and therefore some sort of text structure is required to make the communication simpler and more efficient. It was decided that a JSON type text structure would be able to send information in the most efficient way, allowing for easier parsing when receiving a message.

Our system required that there be multiple communications going in different directions between the different devices. Because of the complicated communication design of our system, we decided to use multiple different subscriptions so that it was clear which messages were being published to which application. These are:

1. _FindADesk_ProcessingToWeb_

The desktop application needs to publish information to the web application regarding the current state of the university study spaces, including the number of buildings, the building names, number of rooms in each building, room names and the number of tables and chairs in each room. This is sent as an array of &#39;room&#39; objects.

![](RackMultipart20200503-4-w63zyv_html_ff76c7401ad0712c.png)

1. _FindADesk_WebToProcessing_

Likewise the desktop application is able to make a request to the server to get all the information regarding the buildings, rooms and chairs that the web application has saved in the database.

1. _FindADesk_StackToWeb_

The M5Stack publishes to the web application, sending information regarding the current state of the particular chair it is on (whether this be &quot;free&quot;, &quot;lunch&quot;, &quot;occupied&quot; or &quot;booked&quot;).

![](RackMultipart20200503-4-w63zyv_html_7881f03ff553f937.png)

1. _FindADesk\_\_\_WebToStack_

The web application also needs to publish information to the M5Stack, informing it if a student has made a booking.

![](RackMultipart20200503-4-w63zyv_html_88f306f626d1e5fa.png)

1. _FindADesk_StackToProcessing_

Finally, the M5Stack publishes information to the desktop application regarding any faulty chairs that the admin team will want to respond to.

![](RackMultipart20200503-4-w63zyv_html_61e10a78fda8f3ad.png)

# 1 f) Details of the data persistence mechanisms in use (including a rational for your choice)

To achieve data persistence, we originally tried using the browser&#39;s local storage to store the data. However this would rely on the other sub-systems continuously sending out messages to ensure the web pages were concurrent with the current state of the rooms and chairs. Furthermore, the user would have to be on the website whilst a message was received from the desktop application or the stack which would result in missed data if the page crashed or was closed. Also, if a user was to delete their local storage then they would again lose all the information and could potentially try to make a booking on a chair that was already occupied by someone else.

Following this we considered using an SQL database due to some of the entities having relational features (e.g. each building contains many rooms and each room contains many chairs). However, as we were investigating this avenue, we realised that NoSQL had the advantage of allowing us to reuse the same JSON structures that we were already using to communicate, removing the need to design a relational database. Therefore, we decided to use MongoDB as it is well supported with node.js and express.

The database schemas were designed as below, with the room objects containing an array of chair objects. The &#39;freeChairs&#39; attribute is calculated based on the number of chairs currently in the &#39;free&#39; state. As mentioned previously, the &#39;chair&#39; attribute is calculated by multiplying the number of tables by four (it is assumed there will be 4 chairs per table for this prototype).

roomSchema chairSchema

![](RackMultipart20200503-4-w63zyv_html_d2389767d1d70c6a.png) ![](RackMultipart20200503-4-w63zyv_html_46f605aebf74369e.png)

#

# 1g) Details of web technologies in use (including a rational for your choice)

In order to build on our original wireframes and get a minimal viable product working, we originally built a simple static website with HTML CSS and JavaScript (as mentioned before using the browser local storage for data persistence). As our application developed over subsequent sprints, we realised that we would need a server and back-end to process the communication protocols and data-persistence mechanisms.

As we wanted to build a fast-scalable application which wouldn&#39;t need to be CPU intensive, we decided to use Node JS as it also provides a lot of features and doesn&#39;t involve using another language for the backend. We also used the framework Express as it provides a lot of tools to quickly and easily build a server-side application with minimal hassle.

As our website would require dynamic HTML population with information received from the M5 stack and processing, it was decided that a templating language would be needed. We chose EJS as it would allow for easily creating HTML elements with plain JavaScript.

# 2a) Breakdown of project into sprints (showing the users stories implemented in each).

SPRINT 1:

Sprint one involved group brainstorming, designing basic UI, and converting paper prototypes to tangible software. The overall objective for the first sprint was to implement a basic working version of each subsystem which could then be developed in later sprints.

Goals:

- To solve the overarching user story of both students&#39; and administrators&#39; need for a straightforward, easy to use UI for each of the subsystems which visually represent the product&#39;s concept and functionality.
- Agreeing on design of basic UI based on user feedback from paper prototypes
- Using feedback gathered through Wizard of Oz techniques to determine basic building blocks for each subsystem from which to build out the rest of the program
- Decide on the initial stack functionality and placement - we were unsure at this stage exactly how the M5Stack would be incorporated into the system design.

Sprint one was heavily design oriented, using user feedback gathered through Wizard of Oz techniques on the initial paper prototype to determine the basic building blocks for each subsystem from which to build out the rest of the program. At this stage, little functionality was implemented other than to mirror the basic visual layout of the wireframes, with the goal of gathering further UI-related user feedback in a software context. This involved designing static HTML and CSS pages for the website and for the stack to display single words such as &quot;booked&quot; or &quot;occupied&quot; to indicate chair status. For the desktop application this involved developing the basic dropdown menus for navigation through buildings and rooms, as well as graphic representation of the tables and chairs within each room.

To evaluate the work of this sprint we had a group meeting where each subsystem was reviewed as a team. We also asked for some volunteers to run through the web application to test whether our UI made sense to those who were unfamiliar with the design. We came to the decision that placing the M5Stack on the chair and using the accelerometer to check if a chair was occupied (as opposed to users pressing a button) would remove the problem of users forgetting to check in themselves. This decision was facilitated by user feedback.

Sprint 2:

We agreed the next most important feature to implement was communication between the 3 different subsystems, allowing us to have a functioning minimal viable product - this became a focus of sprint 2. We also aimed to improve on user experience based on the key feedback points obtained from the first sprint.

Goals:

- Following the &#39;substitution&#39; principle, deciding to establish a common contract between all modules via the MQTT protocol.
- Agreeing on the MQTT subscriptions for each subsystem and the structure and content of data sent via MQTT.
- Minor bug fixing and optimization of work completed in sprint 1.
- Deciding on which additional functionality was feasible and worthwhile given the aim of completing a functional prototype.
- Following the &#39;Open/closed&#39; principle we implemented a &#39;state machine&#39; to define each state of the stack. This would allow us to implement additional states in the future whilst ensuring the fundamental state mechanism.

For the website, setting up a communication with the MQTT broker involved linking the HTML pages with JavaScript files. This allowed for connecting and subscribing to the correct topic, as well as applying functions to connect DOM elements to the publishing of messages to the MQTT. At this stage a single &#39;chair&#39; HTML element was chosen to act as the button which, when clicked, sent a simple text message with the word &#39;booked&#39;. The JavaScript would simply console log any messages received from the other subsystems.

For the desktop application, the creation of classes and objects representing chairs, desks, rooms and buildings became necessary in order to ensure that data persisted between what was visually represented for the administrator and what was sent to the website. Initially, the JSON string sent to the website contained far more information than was needed, and our initial method required chairs being sent to the website one at a time, requiring far longer and more complex JSON objects to be built and parsed. Instead, the group agreed on a strategy to build the IDs so that information could be sent on a per room basis. This meant we had to simplify some initial design choices – for example we had hoped to have desks of variable size demonstrable in the prototype, but the additional complexity balanced against the relative gain forced us to abandon this feature.

It became apparent that having communications going in multiple directions and with different messages would be difficult to process (as it was not clear which messages were for meant for which subsystem). We decided that we would need multiple MQTT topics that the subsystems can subscribe and publish to. To help prioritise our backlog and add features which best fit our user stories, we assigned one of our team members as the &#39;Product Owner&#39; for future sprints, taking the role of an exemplary customer and focusing design decisions to add the most value.

Sprint 3:

The priorities in this sprint were to implement a data persistence mechanism to store data and to finalise the format of the JSON messages being sent between the different subsystems using MQTT. Also, we aimed to implement more functionality based on the requirements of the system and needs of the user.

Goals:

- Agree on the different subscription names we would need for all the different MQTT messaging directions.
- Implement functions in the web application allowing for dynamic HTML page loading of buildings, rooms and number of chairs based on the received messages from the desktop application.
- Implement some basic data persistence on the web application, using local storage in the browser.
- Refactor M5Stack code so that the chair stays in the &#39;occupied&#39; state even when it doesn&#39;t detect movement for a few seconds (based on user feedback).
- Add an RFID scanner to the M5Stack so that users can scan their U-Card and authenticate their chair booking.

- Implement an add/remove room and desk feature to desktop app, finalizing basic desktop functionality.

Following discussions with the product owner member of the team, the UI wireframes were redesigned for each of the subsystems. Some of the key points from previous user feedback were that the colour key for the chairs on the website was not obvious and that users were not sure how they would recognise their chair when they would get to the study space.

The JavaScript on the web application was extended to parse JSON strings sent from the desktop through the MQTT. It then saved the information from the JSON string in an array of JSON objects which were subsequently saved in the local storage of the browser. The JavaScript file was linked with all the HTML pages so that the MQTT messages could be received and processed regardless of the current page. The formal JSON object to be sent from the web app to the M5Stack was also finalised and the code implemented to publish it as a string through the MQTT.

The processing app was extended so that the administrator was able to add rooms and desks. A textbox was implemented so that the user was able to name the room before adding it. This was not necessary for the desk – an automatically generated id (8th table = table id 8) was sufficient. This was in response to the user story that the administrator will want to create new study spaces at their university and display this information to students.

Unfortunately, we were unable to interface the RFID scanner with the M5Stack - this may have been due to the fact that eBay bought MFRC522&#39;s can often be faulty. As a result of this, one of the goals for Sprint 4 will be to design a suitable alternative so that users can access the chair after booking it.

When we evaluated our product at the end of sprint 3 it became obvious that the architecture of the web application would have to be redesigned. This was largely because using local storage as the data persistence mechanism came with many flaws (please see data persistence section above). It was decided that a server-based web application would improve the functionality of the website whilst allowing for more advanced data persistence mechanisms (such as an actual database).

Sprint 4:

The main focus of sprint 4 was to convert the web application to use a server and to change the data persistence mechanism. We also wanted to add further functionality to the M5Stack and desktop applications by implementing a &#39;faulty chair&#39; feature.

Goals:

- Implement a Node.js web server.
- Change our approach to data persistence and implement the NoSQL database MongoDB.
- Add &#39;broken&#39; and &#39;setup&#39; states to the M5Stack to allow the chair id to be set and to allow the chair to be reported faulty

Express was used as the framework for implementing the web application server. We connected the web application to a local MongoDB database using the JavaScript library Mongoose. EJS was also integrated to help create dynamic web pages based on the data stored in the database) The UI design was updated on the web application based on the feedback from the last sprint (a hover effects on chairs to display the current state and the chair ID given to the user as an identifier of their chair).

The &#39;broken&#39; state (as shown in the M5Stack State Diagram) was added, after consulting the Product Owner, to fulfill the user story which focuses on the librarian wanting a convenient system to report broken chairs **(link to user story)**. The &#39;setup&#39; state was also added to allow administrators (e.g. the university/library workers) to easily set each chair up with an ID that corresponds to its allocated ID in the database - **(link to user story).** A &#39;faulty chair&#39; report was added to the desktop and communication between the stack and desktop was finalised.

#

#

# Social and ethical implications

In terms of the ethics of our project, we made sure to follow the ethical guidelines set out by the university. Participants in our study filled out consent forms are were both briefed and debriefed as to the purpose of each of the individual user studies that we carried out. In terms of the data that we are storing, we are not storing any personal data whatsoever, with all the data that we are storing being related to the layout and design of classrooms. We are not aware of any way in which our user testing could cause harm, and we made sure to give participants the ability to withdraw their responses.

Socially there is potentially some implications that can be considered. This product aims to improve student&#39;s ability to find study spaces, but it also has the potential to hinder students who are less willing to interact with or those who are not aware of the product. In attempt to avoid this situation, desks can only be booked for a limited amount of time (10 mins), and therefore we do not believe that this will pose a problem. Another social consequence to consider is the conflict that might arise when students sit in seats that have already been booked. It might be difficult to enforce the rules of the FindADesk system and it would require a team of administrators most likely to go around carrying out. Nonetheless, the issues caused by the system is not too indifferent to normal student study space conflicts (e.g. moving someone&#39;s things of a desk whilst they have gone to lunch) and therefore we don&#39;t believe that the FindADesk system will have too much of a social impact.

Project Evaluation

a) The project overall turned out to be a success? Talk about how the processing part felt like ticking a box and could have actually been done through the website to simplify things with an admin login? Not sure if we have really done OOP for most the project. We accomplished most of what we set out to do.

b) Implementing above features, better UI. More robust system testing. More User testing. Adapt web app for mobile use. Perhaps with some features not as developed as they could be: different user accounts, RFID scanner etc. A lack of testing?. With a databse is there need for MQTT?

c-d) On the whole the group worked together very well. However there were certainly some difficulties we encountered along the way. Originally when we started the project we had an organised structure with weekly meetings, demoing the applications, getting face to face feedback etc. However when we started working remotely it took some time to get used to the changes. For a few weeks our progress was definitely reduced as we tried to develop a system where we could continue working collaboratively on the project. Previously in the web application we had been doing paired programming, with one person writing the code whilst the other watching and giving instructions and guidance. Remotely this proved to be much more difficult, even with screen sharing. In the end it was decided to split the workload differently, with different people working on different sections, but ensuring regular check-ins and commits to the github repository.

**Future Work**

In terms of work for the future, the first priority would be to add in the features that we were not able to complete for the project. In our initial aims for the project, we had intended for more details to be stored for each individual chair however in the end we decided to fix chairs to desks and instead pass the id&#39;s of desks about, fixing the size of each desk to 4 for simplicity. If we had more data about individual chairs, we might be able to start creating more statistics about usage of chairs and a better overview of how chairs are currently be used. An example could be to perform batch processing once an hour whilst the system is online to assess the usage data of each individual chair. This could be used by the university to understand which student areas are the most popular and find out what chairs are not being used at all to investigate them for faults. To achieve this, we would likely need to use a chair database, and as opposed her current structure, all of the different applications would stream into the database as opposed to sending messages on the MQTT broker, and would then communicate with the database to publish and receive changes from the other applications. This would avoid needing to have the web server running in order to receive data from the database.

In terms of research that we would like to do to perfect the product, studies will need to be conducted to determine the correct level of vibration detection so that the chair stays in the &#39;use&#39; state for the entire duration that a person is sitting in the chair. This is to avoid the undesirable situation of the chair reverting back to free while they are sitting still, or if they get up for a minute or two (which is partly solved using the cumulative movement values in the &#39;use&#39; loop, but the numbers used are only estimates). The vibration detection limits could also vary with stack placement and from stack-to-stack, so this will also need to be investigated before a large-scale installation is carried out.

- _(IF WE DO THE SETUP MODE) Add the functionality to change the chair id by scanning an administrator U-card, entering setup mode and changing it (this may require the addition of a seventh &#39;admin&#39; state._
- Change the &#39;in use&#39; to &#39;lunch&#39; state so that the leftmost button must be pressed twice to go to lunch (to prevent accidental pressing) – **CHANGED BECAUSE OF USER FEEDBACK IN A LATER SPRINT**

Appendix:

**Implementing UCard (RFID) scanning functionality:**

In order to confirm the correct individual is using the chair, the student will need to scan their UCard upon arrival. The UCard acts as an RFID (Radio Frequency Identification Device) and its unique identifier is compared with the ID sent from the web app. If the ID sent from the web app matches the ID scanned, then the student has been successfully authenticated and can begin using the desk.

Reading the ID within the UCard would be achieved using an external RFID reader. The module chosen to achieve this was the MFRC522. The MFRC522 is a highly integrated reader/writer IC for contactless communication at 13.56 MHz. This board is manufactured by NXP but can be purchased from the M5Stack store in an enclosure that connects to the stack&#39;s 4-pin &#39;GROVE&#39; connector. As the delivery times from the online store were large, the standalone MFRC522 board was purchased from eBay, this unit did not include a GROVE interface however. This module was therefore connected to the stack&#39;s I/O bus via jump cables:

The MFRC522 supports two communication protocols to communicate with the stack, I2C (Inter-Integrated Circuit) and SPO (Serial Peripheral Interface). I2C is sometimes preferred over SPI because it allows for multiple &#39;slave&#39; devices to communicate with multiple &#39;masters&#39; (the stack in this case) using only two lines. One to transmit the data (SDA) and one to carry a synchronising clock signal (SCL). As there are only two lines, I2C requires each slave to be addressed and this is reflected in the MFRC522 object within the source code where the constructor requires an address to be provided when I2C mode is utilised:

_MFRC522(byte chipAddress);_

SPI offers faster data rates compared to I2C however needs at least 4 lines to be utilised, a Clock (SCK), a line to transfer data from the CPU to the peripheral MOSI, a line to transfer data from the peripheral back to the CPU (MISO) and a chip select line (CS) to select the peripheral in question (hence many more lines may be needed for multiple devices).

Unfortunately, we were unable to get the MFRC522 to interface with the stack, using either of these connection protocols. This may have been due to the fact that eBay bought MFRC522&#39;s can often be faulty.

![Inserting image...](RackMultipart20200503-4-w63zyv_html_528a6f3a09f025d.png)
